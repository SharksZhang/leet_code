# Catalog

[TOC]



### 3. greedy:

#### 455. Assign Cookies

#### 376. Wiggle Subsequence

#### 402. Remove K Digits 

本题最核心的部分是找到贪心算法的每次最优解。在第一遍练习时，找到了最优解的规律。但是没有想到使用栈来连续向前比较。

心得：

1. 当需要提高算法时间复杂度时，应该考虑引入栈，队列，集合等数据结构进行优化。
2. 对于双向链表的操作不熟悉。
3. 解贪心问题，画图，举例子非常重要
4. 审题一定要认真。

#### 55. Jump Game

#### 45. Jump Game II

```
Jump as far as possible but lazily.

[2, 3, 1, 1, 4]
i    nums[i]   steps   near   far
-      -         0       0     0
0      2         0       0     2
1      3         1       2     4
2      1         1       2     4
3      1         2       4     4
4      4         2       4     8
```

Time complexity: O(n)
Space complexity: O(1)

在O(n)的解法中，for循环既更新最大值，有在i大于 当前位置是进行计数。每次找每一段最开的

自己使用的O(n2)的算法，是因为需要用一个for循环记录每次最优的点。

#### 452. Minimum Number of Arrows to Burst Balloons

##### 此问题涉及到的知识点：

1. java如何表示负无穷
2. comparable 如何使用

java比较器系统学习

1. 多维数组排序

2. ```
   	Array.Sort(points, new Comparison<int[]>((a,b) => a[0]-b[0]));
   ```

3. java int 的最大最小值 [[-2147483648,2147483647]]

##### 错误记录：

未考虑负数，比较时初始值使用-1

#### 122. Best Time to Buy and Sell Stock II

#### 134. Gas Station

### 4. 递归，回溯，分治

当问题每一步都有相同的解法时，就可以使用递归。

感觉回溯是多重的递归。

#### 704. Binary Search

#### 78. subsets

### 位运算法
![Screen Shot 2019-07-05 at 3.54.06 PM](Screen Shot 2019-07-05 at 3.54.06 PM.png)

与运算的实质是该位存不存在。

位运算可以代表改位存不存在，逻辑&预算可以用来判断该位存不存在。

1<<多少位就可以代表第多少位。1<<多为用来生成总的代表存不存在的个数。

#### 90. Subsets II

1. 去重使用集合

2. 用集合去重时能不能相等可以用equal方法判断一下

3. 集合可以直接对arraylist去重

   

回溯法和位云算法的算法复杂度都是o(n2)

#### 40. Combination Sum II

生成子集的两种方法，位运算法，回溯法。

在使用两种方法，不进行剪枝的情况下，时间复杂度太差，使用回溯进行剪枝。

注意剪枝的条件，尽量去优化剪去不必要的分支。



#### 22. Generate Parentheses

1. 使用回溯时先实现不剪枝的方法，然后再剪枝
2. 使用return剪枝时，要注意后面分支还要不要执行
3. 在回溯中所有的操作都是对称的，删除后，回溯回来的时候要添加。
4. 只递归，不回溯的情况下就可以不进行删减操作
5. 剪枝的两条路径的两个if语句就相当于按照这两种情况进行遍历。
6. 有的问题是不需要回溯的，只需要递归就可以了，递归和回溯的区别就是需不需要把状态退回来。
7. 递归时直接在参数位置进行计算时，每次递归会自动copy当前值，每层递归都会保存一个值，所以不需要回退，如果使用一个引用，则需要回溯，在回退时，把修改的删除回来。

回溯问题解法：

1. 递归枚举所有
2. 使用条件语句剪枝
3. 回溯状态
4. 找到退出结果条件
5. 条件语句就是仅有的枚举分支



#### 51. N-Queens

做此问题时遇到两个问题：

1. 回溯过程中如何保存当前状态?

   在每次递归增加临时变量，可以保存当前的状态。

2. 二维数组是引用，后续函数的会改变应用的值

   再次注意引用，后续函数的改变会改变引用的值。

3. 二维数组如何mark

   使用方向坐标对二维数组进行mark